<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Patterns - The Rust Reference</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="notation.html"><strong>1.</strong> Notation</a></li><li><a href="lexical-structure.html"><strong>2.</strong> Lexical structure</a></li><li><ul class="section"><li><a href="input-format.html"><strong>2.1.</strong> Input format</a></li><li><a href="keywords.html"><strong>2.2.</strong> Keywords</a></li><li><a href="identifiers.html"><strong>2.3.</strong> Identifiers</a></li><li><a href="comments.html"><strong>2.4.</strong> Comments</a></li><li><a href="whitespace.html"><strong>2.5.</strong> Whitespace</a></li><li><a href="tokens.html"><strong>2.6.</strong> Tokens</a></li></ul></li><li><a href="macros.html"><strong>3.</strong> Macros</a></li><li><ul class="section"><li><a href="macros-by-example.html"><strong>3.1.</strong> Macros By Example</a></li><li><a href="procedural-macros.html"><strong>3.2.</strong> Procedural Macros</a></li></ul></li><li><a href="crates-and-source-files.html"><strong>4.</strong> Crates and source files</a></li><li><a href="items-and-attributes.html"><strong>5.</strong> Items and attributes</a></li><li><ul class="section"><li><a href="items.html"><strong>5.1.</strong> Items</a></li><li><a href="visibility-and-privacy.html"><strong>5.2.</strong> Visibility and Privacy</a></li><li><a href="attributes.html"><strong>5.3.</strong> Attributes</a></li></ul></li><li><a href="statements-and-expressions.html"><strong>6.</strong> Statements and expressions</a></li><li><ul class="section"><li><a href="statements.html"><strong>6.1.</strong> Statements</a></li><li><a href="expressions.html"><strong>6.2.</strong> Expressions</a></li><li><a href="paths.html"><strong>6.3.</strong> Paths</a></li><li><a href="patterns.html" class="active"><strong>6.4.</strong> Patterns</a></li></ul></li><li><a href="type-system.html"><strong>7.</strong> Type system</a></li><li><ul class="section"><li><a href="types.html"><strong>7.1.</strong> Types</a></li><li><a href="dynamically-sized-types.html"><strong>7.2.</strong> Dynamically Sized Types</a></li><li><a href="interior-mutability.html"><strong>7.3.</strong> Interior mutability</a></li><li><a href="subtyping.html"><strong>7.4.</strong> Subtyping</a></li><li><a href="type-coercions.html"><strong>7.5.</strong> Type coercions</a></li></ul></li><li><a href="special-traits.html"><strong>8.</strong> Special traits</a></li><li><ul class="section"><li><a href="the-copy-trait.html"><strong>8.1.</strong> The Copy trait</a></li><li><a href="the-sized-trait.html"><strong>8.2.</strong> The Sized trait</a></li><li><a href="the-drop-trait.html"><strong>8.3.</strong> The Drop trait</a></li><li><a href="the-deref-trait.html"><strong>8.4.</strong> The Deref trait</a></li><li><a href="the-send-trait.html"><strong>8.5.</strong> The Send trait</a></li><li><a href="the-sync-trait.html"><strong>8.6.</strong> The Sync trait</a></li></ul></li><li><a href="memory-model.html"><strong>9.</strong> Memory model</a></li><li><ul class="section"><li><a href="memory-allocation-and-lifetime.html"><strong>9.1.</strong> Memory allocation and lifetime</a></li><li><a href="memory-ownership.html"><strong>9.2.</strong> Memory ownership</a></li><li><a href="variables.html"><strong>9.3.</strong> Variables</a></li></ul></li><li><a href="linkage.html"><strong>10.</strong> Linkage</a></li><li><a href="unsafety.html"><strong>11.</strong> Unsafety</a></li><li><ul class="section"><li><a href="unsafe-functions.html"><strong>11.1.</strong> Unsafe functions</a></li><li><a href="unsafe-blocks.html"><strong>11.2.</strong> Unsafe blocks</a></li><li><a href="behavior-considered-undefined.html"><strong>11.3.</strong> Behavior considered undefined</a></li><li><a href="behavior-not-considered-unsafe.html"><strong>11.4.</strong> Behavior not considered unsafe</a></li></ul></li><li><a href="influences.html">Appendix: Influences</a></li><li class="affix"><a href="undocumented.html">Appendix: As-yet-undocumented Features</a></li><li class="affix"><a href="glossory.html">Appendix: Glossory</a></li><li class="affix"><a href="grammar.html">Appendix: Grammar</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="patterns.html#patterns" id="patterns"><h1>Patterns</h1></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Pattern</em> :<a name="pattern-syntax"></a><br />
      <a href="patterns.html#literal-pattern-syntax"><em>LiteralPattern</em></a><br />
   | <a href="patterns.html#wildcard-pattern-syntax"><em>WildcardPattern</em></a><br />
   | <a href="patterns.html#range-pattern-syntax"><em>RangePattern</em></a><br />
   | <a href="patterns.html#reference-pattern-syntax"><em>ReferencePattern</em></a><br />
   | <a href="patterns.html#identifier-pattern-syntax"><em>IdentifierPattern</em></a><br />
   | <a href="patterns.html#box-pattern-syntax"><em>BoxPattern</em></a><br />
   | <a href="patterns.html#struct-pattern-syntax"><em>StructPattern</em></a><br />
   | <a href="patterns.html#tuple-pattern-syntax"><em>TuplePattern</em></a><br />
   | <a href="patterns.html#tuplestruct-pattern-syntax"><em>TupleStructPattern</em></a><br />
   | <a href="patterns.html#slice-pattern-syntax"><em>SlicePattern</em></a><br />
   | <a href="patterns.html#path-pattern-syntax"><em>PathPattern</em></a></p>
</blockquote>
<p>Patterns in Rust are used to match values against structures and to,
optionally, bind variables to values inside these structures. They are also
used in variable declarations and function/closure parameters, though most of
the time simply as an identifier that binds to a value.</p>
<p>For example, the pattern used in:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# struct Car;
# struct Computer;
# struct Person {
#     name: String,
#     car: Option&lt;Car&gt;,
#     computer: Option&lt;Computer&gt;,
#     age: u8,
# }
# let person = Person {
#     name: String::from(&quot;John&quot;),
#     car: Some(Car),
#     computer: None,
#     age: 15,
# };
if let
    Person {
        car: Some(_),
        age: person_age @ 13...19,
        name: ref person_name,
        ..
    } = person
{
    println!(&quot;{} has a car and is {} years old.&quot;, person_name, person_age);
}

#}</code></pre></pre>
<p>does four things:</p>
<ul>
<li>Tests if <code>person</code> has the <code>car</code> field filled with something.</li>
<li>Tests if the person's <code>age</code> field is between 13 and 19, and binds its value to
the <code>person_age</code> variable.</li>
<li>Binds a reference to the <code>name</code> field to the variable <code>person_name</code>.</li>
<li>Ignores the rest of the fields of <code>person</code>, i.e., they can have any value and
are not bound to any variables.</li>
</ul>
<p>Patterns are used in:</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> declarations</a></li>
<li><a href="items.html#functions">Function</a> and <a href="expressions.html#closure-expressions">closure</a>
parameters</li>
<li><a href="expressions.html#match-expressions"><code>match</code> expressions</a></li>
<li><a href="expressions.html#if-let-expressions"><code>if let</code> expressions</a></li>
<li><a href="expressions.html#while-let-loops"><code>while let</code> expressions</a></li>
<li>Inside other patterns</li>
</ul>
<a class="header" href="patterns.html#destructuring" id="destructuring"><h2>Destructuring</h2></a>
<p>Patterns can be used to <em>destructure</em> structs, enums, and tuples. Destructuring
breaks a value up into its component pieces. The syntax used is almost the same as
when creating such values. When destructing a data structure with named (but
not numbered) fields, it is allowed to write <code>fieldname</code> as a shorthand for
<code>fieldname: fieldname</code>. In a pattern whose head expression has a <code>struct</code>,
<code>enum</code> or <code>tupl</code> type, a placeholder (<code>_</code>) stands for a <em>single</em> data field,
whereas a wildcard <code>..</code> stands for <em>all</em> the remaining fields of a particular variant.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# enum Message {
#     Quit,
#     WriteString(String),
#     Move { x: i32, y: i32 },
#     ChangeColor(u8, u8, u8),
# }
# let message = Message::Quit;
match message {
    Message::Quit =&gt; println!(&quot;Quit&quot;),
    Message::WriteString(write) =&gt; println!(&quot;{}&quot;, &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!(&quot;move {} horizontally&quot;, x),
    Message::Move{ .. } =&gt; println!(&quot;other move&quot;),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!(&quot;color change, red: {}, green: {}&quot;, red, green);
    }
};

#}</code></pre></pre>
<a class="header" href="patterns.html#refutability" id="refutability"><h2>Refutability</h2></a>
<p>A pattern is said to be <em>Refutable</em> when it <strong>has the possibily of not being matched</strong>
by the value it is being matched against. <em>Irrefutable</em> patterns, on the other hand,
always match the value they are being matched againt. Examples:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let (x, y) = (1, 2);               // &quot;(x, y)&quot; is an irrefutable pattern

if let (a, 3) = (1, 2) {           // &quot;(a, 3)&quot; is refutable, and will not match
    panic!(&quot;Shouldn't reach here&quot;);
} else if let (a, 4) = (3, 4) {    // &quot;(a, 4)&quot; is refutable, and will match
    println!(&quot;Matched ({}, 4)&quot;, a);
}

#}</code></pre></pre>
<a class="header" href="patterns.html#literal-patterns" id="literal-patterns"><h2>Literal patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LiteralPattern</em> :<a name="literal-pattern-syntax"></a><br />
      BOOLEAN_LITERAL<br />
   | CHAR_LITERAL<br />
   | BYTE_LITERAL<br />
   | STRING_LITERAL<br />
   | RAW_STRING_LITERAL<br />
   | BYTE_STRING_LITERAL<br />
   | RAW_BYTE_STRING_LITERAL<br />
   | <code>-</code><sup>?</sup> INTEGER_LITERAL<br />
   | <code>-</code><sup>?</sup> FLOAT_LITERAL</p>
</blockquote>
<p><em>Literal patterns</em> match exactly the value they represent. Since negative numbers are
not literals in Rust, literal patterns also accept an optional minus sign before the
literal.</p>
<p>Floating-point literals are currently accepted, but due to the complexity of comparing
them, they are going to be forbidden on literal patterns in a future version of Rust (see
<a href="https://github.com/rust-lang/rust/issues/41620">issue #41620</a>).</p>
<p>Literal patterns are always refutable.</p>
<p>Examples:</p>
<!-- FIXME more examples -->
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for i in -2..5 {
    match i {
        -1 =&gt; println!(&quot;It's minus one&quot;),
        1 =&gt; println!(&quot;It's a one&quot;),
        2|4 =&gt; println!(&quot;It's either a two or a four&quot;),
        _ =&gt; println!(&quot;Matched none of the arms&quot;),
    }
}

#}</code></pre></pre>
<p>prints</p>
<pre><code class="language-text">Matched none of the arms
It's minus one
Matched none of the arms
It's a one
It's either a two or a four
Matched none of the arms
It's either a two or a four
</code></pre>
<a class="header" href="patterns.html#wildcard-pattern" id="wildcard-pattern"><h2>Wildcard pattern</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>WildcardPattern</em> :<a name="wildcard-pattern-syntax"></a><br />
   <code>_</code></p>
</blockquote>
<!-- FIXME explain the wildcard pattern -->
<p>The <em>wildcard pattern</em> matches any value.</p>
<p>For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# let x = 20;
let (a, _) = (10, x);   // the x is always matched by _
# assert_eq!(a, 10);

#}</code></pre></pre>
<p>The wildcard pattern is always irrefutable.</p>
<!-- FIXME examples -->
<!-- FIXME example: ignore function parameter -->
<!-- FIXME example: ignore a field from a tuple -->
<!-- FIXME example: ignore a field from a struct -->
<!-- FIXME example: ignore the field of an enum: use Some(_) -->
<a class="header" href="patterns.html#range-patterns" id="range-patterns"><h2>Range patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>RangePattern</em> :<a name="range-pattern-syntax"></a><br />
    <em>RangePatternBound</em> <code>...</code> <em>RangePatternBound</em></p>
<p><em>RangePatternBound</em> :<br />
      <em>Literal</em><br />
   | <em>PathForExpression</em><br />
   | <em>QualifiedPathForExpression</em></p>
</blockquote>
<p>Range patterns match values that are within the closed range defined by its lower and
upper bounds. For example, a pattern <code>'m'...'p'</code> will match only the values <code>'m'</code>, <code>'n'</code>,
<code>'o'</code>, and <code>'p'</code>. The bounds can be literals or paths that point to constant values.</p>
<p>A pattern a <code>...</code> b must always have a ≤ b. Thus, it is not possible to have a range
pattern <code>10...0</code>.</p>
<p>Range patterns only work on scalar types. The accepted types are:</p>
<ul>
<li>Integer types (u8, i8, u16, i16, usize, isize, etc.).</li>
<li>Character types (char).</li>
<li>Floating point types (f32 and f64). This is being deprecated and will not be available
in a future version of Rust (see
<a href="https://github.com/rust-lang/rust/issues/41620">issue #41620</a>).</li>
</ul>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# let c = 'f';
let valid_variable = match c {
    'a'...'z' =&gt; true,
    'A'...'Z' =&gt; true,
    'α'...'ω' =&gt; true,
    _ =&gt; false,
};

# let ph = 10;
println!(&quot;{}&quot;, match ph {
    0...6 =&gt; &quot;acid&quot;,
    7 =&gt; &quot;neutral&quot;,
    8...14 =&gt; &quot;base&quot;,
    _ =&gt; unreachable!(),
});

// using paths to constants:
# const TROPOSPHERE_MIN : u8 = 6;
# const TROPOSPHERE_MAX : u8 = 20;
# 
# const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;
# const STRATOSPHERE_MAX : u8 = 50;
# 
# const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;
# const MESOSPHERE_MAX : u8 = 85;
# 
# let altitude = 70;
# 
println!(&quot;{}&quot;, match altitude {
    TROPOSPHERE_MIN...TROPOSPHERE_MAX =&gt; &quot;troposphere&quot;,
    STRATOSPHERE_MIN...STRATOSPHERE_MAX =&gt; &quot;stratosphere&quot;,
    MESOSPHERE_MIN...MESOSPHERE_MAX =&gt; &quot;mesosphere&quot;,
    _ =&gt; &quot;outer space, maybe&quot;,
});

# pub mod binary {
#     pub const MEGA : u64 = 1024*1024;
#     pub const GIGA : u64 = 1024*1024*1024;
# }
# let n_items = 20_832_425;
# let bytes_per_item = 12;
if let size @ binary::MEGA...binary::GIGA = n_items * bytes_per_item {
    println!(&quot;It fits and occupies {} bytes&quot;, size);
}

# trait MaxValue {
#     const MAX: u64;
# }
# impl MaxValue for u8 {
#     const MAX: u64 = (1 &lt;&lt; 8) - 1;
# }
# impl MaxValue for u16 {
#     const MAX: u64 = (1 &lt;&lt; 16) - 1;
# }
# impl MaxValue for u32 {
#     const MAX: u64 = (1 &lt;&lt; 32) - 1;
# }
// using qualified paths:
println!(&quot;{}&quot;, match 0xfacade {
    0 ... &lt;u8 as MaxValue&gt;::MAX =&gt; &quot;fits in a u8&quot;,
    0 ... &lt;u16 as MaxValue&gt;::MAX =&gt; &quot;fits in a u16&quot;,
    0 ... &lt;u32 as MaxValue&gt;::MAX =&gt; &quot;fits in a u32&quot;,
    _ =&gt; &quot;too big&quot;,
});


#}</code></pre></pre>
<p>Range patterns are always refutable, even when they cover the complete set of possible
values of a type. For example, <code>0u8...255u8</code> is refutable even though it covers all
possible values of <code>u8</code>.</p>
<!-- FIXME change _PathForExpression_ to _PathInExpression_ ? -->
<!-- FIXME put this on the match section
A range pattern may not be a sub-range of another range pattern inside the same `match`.
-->
<a class="header" href="patterns.html#reference-patterns" id="reference-patterns"><h2>Reference patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ReferencePattern</em> :<a name="reference-pattern-syntax"></a><br />
   (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code><sup>?</sup> <em>Pattern</em></p>
</blockquote>
<!-- FIXME: explain reference patterns  -->
<!-- FIXME: explain why the `&&` is part of the grammar -->
<p>Patterns can also dereference pointers by using the <code>&amp;</code>, <code>&amp;mut</code> and <code>box</code>
symbols, as appropriate. For example, these two matches on <code>x: &amp;i32</code> are
equivalent:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# let x = &amp;3;
let y = match *x { 0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };
let z = match x { &amp;0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };

assert_eq!(y, z);

#}</code></pre></pre>
<!-- when is this pattern type refutable? -->
<a class="header" href="patterns.html#identifier-patterns" id="identifier-patterns"><h2>Identifier patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IdentifierPattern</em> :<a name="identifier-pattern-syntax"></a><br />
      <code>mut</code><sup>?</sup> IDENTIFIER (<code>@</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a> ) <sup>?</sup><br />
   | <code>ref</code> <code>mut</code><sup>?</sup> IDENTIFIER (<code>@</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a> ) <sup>?</sup></p>
</blockquote>
<!-- FIXME: explain identifier patterns -->
<!-- FIXME: mention that IDENTIFIER pattern is the commonly used one in let and function parameters -->
<p><em>Identifier patterns</em> bind the value they match to a variable.</p>
<p>Patterns that consist of only an identifier, possibly with a <code>mut</code>, like
<code>variable</code>, <code>x</code>, and <code>y</code> below:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut variable = 10;
fn sum(x: i32, y: i32) -&gt; i32 {
#    x + y
#}

#}</code></pre></pre>
<p>match any value and bind it to that identifier. This is the most commonly
used pattern in variable declarations and function/closure parameters.</p>
<p>To bind non-trivial patterns to a variable, the use of the syntax <code>variable @ subpattern</code> is needed. For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}

#}</code></pre></pre>
<p>binds to <code>e</code> the value 1 (not the entire range: the range is a range subpattern).</p>
<p>By default, identifier patterns bind a variable to a copy or move of the
matched value (depending whether the matched value implements the Copy trait).
This can be changed to bind to a reference by using the <code>ref</code> keyword,
or to a mutable reference using <code>ref mut</code>. For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// TODO

#}</code></pre></pre>
<p>in the first match arm, the value is copied. In the second one, a reference
to the same memory location is bound to the variable. This syntax is needed
because in destructuring subpatterns we can't apply the <code>&amp;</code> operator to
the value's fields. For example:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail"># #![allow(unused_variables)]
#fn main() {
// TODO

struct Person {
    name: String,
}

if let Person{&amp; name: person_name} = value {
}


#}</code></pre></pre>
<p>is not valid. What we must do is:</p>
<pre><code>// TODO

struct Person {
    name: String,
}

if let Person(name: ref person_name) = value {
}
</code></pre>
<p>Thus, <code>ref</code> is not something that is being matched against. Its objective is
exclusively to make the matched binding a reference, instead of potentially
copying or moving the value of what was matched.</p>
<!-- FIXME cannot bind by-move and by-ref in the same pattern -->
<!-- FIXME explain the difference between `& var` and `ref var` in patterns -->
<!-- when is this pattern type refutable? -->
<a class="header" href="patterns.html#box-pattern" id="box-pattern"><h2>Box pattern</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BoxPattern</em> :<a name="box-pattern-syntax"></a><br />
   <code>box</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a></p>
</blockquote>
<!-- FIXME: explain box patterns -->
<!-- FIXME: they're not stable -->
<!-- when is this pattern type refutable? -->
<a class="header" href="patterns.html#struct-patterns" id="struct-patterns"><h2>Struct patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>StructPattern</em> :<a name="struct-pattern-syntax"></a><br />
   <em>Path</em> <code>{</code><br />
      <em>StructPatternElements</em> <sup>?</sup><br />
   <code>}</code></p>
<p><em>StructPatternElements</em> :<br />
      <em>StructPatternFields</em> (<code>,</code> | <code>,</code> <em>StructPatternEtCetera</em>)<sup>?</sup><br />
   | <em>StructPatternEtCetera</em></p>
<p><em>StructPatternFields</em> :<br />
   <em>StructPatternField</em> (<code>,</code> <em>StructPatternField</em>) <sup>*</sup></p>
<p><em>StructPatternField</em> :<br />
   <em>OuterAttribute</em> <sup>*</sup><br />
   (<br />
         INTEGER_LITERAL <code>:</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a><br />
      | IDENTIFIER <code>:</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a><br />
      | <code>box</code><sup>?</sup> <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup>
IDENTIFIER<br />
   )</p>
<p><em>StructPatternEtCetera</em> :<br />
   <em>OuterAttribute</em> <sup>*</sup><br />
   <code>..</code></p>
</blockquote>
<!-- FIXME: explain struct patterns -->
<!-- FIXME: destructuring patterns -->
<p>Struct patterns match ...</p>
<!-- when is this pattern type refutable? -->
<a class="header" href="patterns.html#tuplestruct-patterns" id="tuplestruct-patterns"><h2>TupleStruct patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleStructPattern</em> :<a name="tuplestruct-pattern-syntax"></a><br />
   <em>Path</em> <code>(</code> <em>TupleStructItems</em> <code>)</code></p>
<p><em>TupleStructItems</em> :<br />
      <a href="patterns.html#pattern-syntax"><em>Pattern</em></a> ( <code>,</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a> )<sup>*</sup> <code>,</code><sup>?</sup><br />
   | (<a href="patterns.html#pattern-syntax"><em>Pattern</em></a> <code>,</code>)<sup>*</sup> <code>..</code> ( (<code>,</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup> )<sup>?</sup></p>
</blockquote>
<!-- FIXME: explain tuple struct patterns -->
<!-- FIXME: includes enum variants? Yes! -->
<!-- when is this pattern type refutable? -->
<a class="header" href="patterns.html#tuple-patterns" id="tuple-patterns"><h2>Tuple patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TuplePattern</em> :<a name="tuple-pattern-syntax"></a><br />
   <code>(</code> <em>TupplePatternItems</em><sup>?</sup> <code>)</code></p>
<p><em>TuplePatternItems</em> :<br />
      <a href="patterns.html#pattern-syntax"><em>Pattern</em></a> <code>,</code><br />
   | <a href="patterns.html#pattern-syntax"><em>Pattern</em></a> (<code>,</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup><br />
   | (<a href="patterns.html#pattern-syntax"><em>Pattern</em></a> <code>,</code>)<sup>*</sup> <code>..</code> ( (<code>,</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup> )<sup>?</sup></p>
</blockquote>
<!-- FIXME: explain tuple patterns -->
<!-- when is this pattern type refutable? -->
<!-- NOT STABLE:
<a class="header" href="patterns.html#slice-patterns" id="slice-patterns"><h2>Slice patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SlicePattern</em> :<a name="slice-pattern-syntax"></a><br />
   <code>[</code> <strong>FIXME</strong> <code>]</code></p>
</blockquote>
<p>--&gt;</p>
<!-- FIXME: explain slice patterns -->
<!-- FIXME: this is not stable -->
<!-- when is this pattern type refutable? -->
<a class="header" href="patterns.html#path-patterns" id="path-patterns"><h2>Path patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PathPattern</em> :<a name="path-pattern-syntax"></a><br />
      <em>PathForExpression</em><br />
   | <em>QualifiedPathForExpression</em></p>
</blockquote>
<!-- FIXME: explain paths in patterns -->
<!-- when is this pattern type refutable? -->

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="paths.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="type-system.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="paths.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="type-system.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
