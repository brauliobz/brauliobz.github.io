<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Patterns - The Rust Reference</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="notation.html"><strong>1.</strong> Notation</a></li><li><a href="lexical-structure.html"><strong>2.</strong> Lexical structure</a></li><li><ul class="section"><li><a href="input-format.html"><strong>2.1.</strong> Input format</a></li><li><a href="keywords.html"><strong>2.2.</strong> Keywords</a></li><li><a href="identifiers.html"><strong>2.3.</strong> Identifiers</a></li><li><a href="comments.html"><strong>2.4.</strong> Comments</a></li><li><a href="whitespace.html"><strong>2.5.</strong> Whitespace</a></li><li><a href="tokens.html"><strong>2.6.</strong> Tokens</a></li></ul></li><li><a href="macros.html"><strong>3.</strong> Macros</a></li><li><ul class="section"><li><a href="macros-by-example.html"><strong>3.1.</strong> Macros By Example</a></li><li><a href="procedural-macros.html"><strong>3.2.</strong> Procedural Macros</a></li></ul></li><li><a href="crates-and-source-files.html"><strong>4.</strong> Crates and source files</a></li><li><a href="items-and-attributes.html"><strong>5.</strong> Items and attributes</a></li><li><ul class="section"><li><a href="items.html"><strong>5.1.</strong> Items</a></li><li><a href="visibility-and-privacy.html"><strong>5.2.</strong> Visibility and Privacy</a></li><li><a href="attributes.html"><strong>5.3.</strong> Attributes</a></li></ul></li><li><a href="statements-and-expressions.html"><strong>6.</strong> Statements and expressions</a></li><li><ul class="section"><li><a href="statements.html"><strong>6.1.</strong> Statements</a></li><li><a href="expressions.html"><strong>6.2.</strong> Expressions</a></li><li><a href="paths.html"><strong>6.3.</strong> Paths</a></li><li><a href="patterns.html" class="active"><strong>6.4.</strong> Patterns</a></li></ul></li><li><a href="type-system.html"><strong>7.</strong> Type system</a></li><li><ul class="section"><li><a href="types.html"><strong>7.1.</strong> Types</a></li><li><a href="subtyping.html"><strong>7.2.</strong> Subtyping</a></li><li><a href="type-coercions.html"><strong>7.3.</strong> Type coercions</a></li></ul></li><li><a href="special-traits.html"><strong>8.</strong> Special traits</a></li><li><ul class="section"><li><a href="the-copy-trait.html"><strong>8.1.</strong> The Copy trait</a></li><li><a href="the-sized-trait.html"><strong>8.2.</strong> The Sized trait</a></li><li><a href="the-drop-trait.html"><strong>8.3.</strong> The Drop trait</a></li><li><a href="the-deref-trait.html"><strong>8.4.</strong> The Deref trait</a></li><li><a href="the-send-trait.html"><strong>8.5.</strong> The Send trait</a></li><li><a href="the-sync-trait.html"><strong>8.6.</strong> The Sync trait</a></li></ul></li><li><a href="memory-model.html"><strong>9.</strong> Memory model</a></li><li><ul class="section"><li><a href="memory-allocation-and-lifetime.html"><strong>9.1.</strong> Memory allocation and lifetime</a></li><li><a href="memory-ownership.html"><strong>9.2.</strong> Memory ownership</a></li><li><a href="variables.html"><strong>9.3.</strong> Variables</a></li></ul></li><li><a href="linkage.html"><strong>10.</strong> Linkage</a></li><li><a href="unsafety.html"><strong>11.</strong> Unsafety</a></li><li><ul class="section"><li><a href="unsafe-functions.html"><strong>11.1.</strong> Unsafe functions</a></li><li><a href="unsafe-blocks.html"><strong>11.2.</strong> Unsafe blocks</a></li><li><a href="behavior-considered-undefined.html"><strong>11.3.</strong> Behavior considered undefined</a></li><li><a href="behavior-not-considered-unsafe.html"><strong>11.4.</strong> Behavior not considered unsafe</a></li></ul></li><li><a href="influences.html">Appendix: Influences</a></li><li class="affix"><a href="undocumented.html">Appendix: As-yet-undocumented Features</a></li><li class="affix"><a href="glossory.html">Appendix: Glossory</a></li><li class="affix"><a href="grammar.html">Appendix: Grammar</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="patterns.html#patterns" id="patterns"><h1>Patterns</h1></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Pattern</em> :<a name="pattern-syntax"></a><br />
      <a href="patterns.html#literal-pattern-syntax"><em>LiteralPattern</em></a><br />
   | <a href="patterns.html#wildcard-pattern-syntax"><em>WildcardPattern</em></a><br />
   | <a href="patterns.html#range-pattern-syntax"><em>RangePattern</em></a><br />
   | <a href="patterns.html#reference-pattern-syntax"><em>ReferencePattern</em></a><br />
   | <a href="patterns.html#identifier-pattern-syntax"><em>IdentifierPattern</em></a><br />
   | <a href="patterns.html#box-pattern-syntax"><em>BoxPattern</em></a><br />
   | <a href="patterns.html#struct-pattern-syntax"><em>StructPattern</em></a><br />
   | <a href="patterns.html#tuple-pattern-syntax"><em>TuplePattern</em></a><br />
   | <a href="patterns.html#tuplestruct-pattern-syntax"><em>TupleStructPattern</em></a><br />
   | <a href="patterns.html#slice-pattern-syntax"><em>SlicePattern</em></a><br />
   | <a href="patterns.html#path-pattern-syntax"><em>PathPattern</em></a></p>
</blockquote>
<p>Patterns in Rust are used to match values against structures and to,
optionally, bind variables to values inside these structures. They are also
used in variable declarations and function/closure parameters, though most of
the time simply as an identifier that binds to any value.</p>
<p>For example, the pattern used in:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# struct Car;
# struct Computer;
# struct Person {
#     name: String,
#     car: Option&lt;Car&gt;,
#     computer: Option&lt;Computer&gt;,
#     age: u8,
# }
# let person = Person {
#     name: String::from(&quot;John&quot;),
#     car: Some(Car),
#     computer: None,
#     age: 15,
# };
if let
    Person {
        car: Some(_),
        age: person_age @ 13...19,
        name: ref person_name,
        ..
    } = person
{
    println!(&quot;{} has a car and is {} years old.&quot;, person_name, person_age);
}

#}</code></pre></pre>
<p>does four things:</p>
<ul>
<li>Tests if <code>person</code> has the <code>car</code> field filled with something.</li>
<li>Tests if the person's <code>age</code> field is between 13 and 19, and binds its value to
the <code>person_age</code> variable.</li>
<li>Binds a reference to the <code>name</code> field to the variable <code>person_name</code>.</li>
<li>Ignores the rest of the fields of <code>person</code>, i.e., they can have any value and
are not bound to any variables.</li>
</ul>
<p>Patterns are used in:</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> declarations</a></li>
<li><a href="items.html#functions">Function</a> and <a href="expressions.html#closure-expressions">closure</a>
parameters</li>
<li><a href="expressions.html#match-expressions"><code>match</code> expressions</a></li>
<li><a href="expressions.html#if-let-expressions"><code>if let</code> expressions</a></li>
<li><a href="expressions.html#while-let-loops"><code>while let</code> expressions</a></li>
<li>Inside other patterns</li>
</ul>
<a class="header" href="patterns.html#destructuring" id="destructuring"><h2>Destructuring</h2></a>
<p>Patterns can be used to <em>destructure</em> structs, enums, and tuples. Destructuring
breaks a value up into its component pieces. The syntax used is the same as
when creating such values. When destructing a data structure with named (but
not numbered) fields, it is allowed to write <code>fieldname</code> as a shorthand for
<code>fieldname: fieldname</code>. In a pattern whose head expression has a <code>struct</code>,
<code>enum</code> or <code>tupl</code> type, a placeholder (<code>_</code>) stands for a <em>single</em> data field,
whereas a wildcard <code>..</code> stands for <em>all</em> the fields of a particular variant.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# enum Message {
#     Quit,
#     WriteString(String),
#     Move { x: i32, y: i32 },
#     ChangeColor(u8, u8, u8),
# }
# let message = Message::Quit;
match message {
    Message::Quit =&gt; println!(&quot;Quit&quot;),
    Message::WriteString(write) =&gt; println!(&quot;{}&quot;, &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!(&quot;move {} horizontally&quot;, x),
    Message::Move{ .. } =&gt; println!(&quot;other move&quot;),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!(&quot;color change, red: {}, green: {}&quot;, red, green);
    }
};

#}</code></pre></pre>
<a class="header" href="patterns.html#refutability" id="refutability"><h2>Refutability</h2></a>
<!-- FIXME: irrefutable patterns -->
<!-- FIXME: which things don't accept irrefutable patterns? -->
<!-- FIXME: which things don't accept refutable patterns? -->
<a class="header" href="patterns.html#literal-patterns" id="literal-patterns"><h2>Literal patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LiteralPattern</em> :<a name="literal-pattern-syntax"></a><br />
   <code>-</code><sup>?</sup> ( CHAR_LITERAL | INTEGER_LITERAL | FLOAT_LITERAL )</p>
</blockquote>
<p><em>Literal patterns</em> match exactly the value they represent. Since negative numbers are
not literals in Rust, literal patterns also accept an optional minus sign before the
literal.</p>
<p>Floating-point literals are currently accepted, but due to the complexity of comparing
them, they are going to be forbidden in a future version of Rust (see
<a href="https://github.com/rust-lang/rust/issues/41620">issue #41620</a>).</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for i in -2..5 {
    match i {
        -1 =&gt; println!(&quot;It's minus one&quot;),
        1 =&gt; println!(&quot;It's a one&quot;),
        2|4 =&gt; println!(&quot;It's either a two or a four&quot;),
        _ =&gt; println!(&quot;Matched none of the arms&quot;),
    }
}

#}</code></pre></pre>
<p>prints</p>
<pre><code class="language-text">Matched none of the arms
It's minus one
Matched none of the arms
It's a one
It's either a two or a four
Matched none of the arms
It's either a two or a four
</code></pre>
<a class="header" href="patterns.html#wildcard-pattern" id="wildcard-pattern"><h2>Wildcard pattern</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>WildcardPattern</em> :<a name="wildcard-pattern-syntax"></a><br />
   <code>_</code></p>
</blockquote>
<!-- FIXME explain the wildcard pattern -->
<p>The <em>wildcard pattern</em> means any value or the value does not matter.</p>
<p>For example:</p>
<pre><code>    
</code></pre>
<!-- FIXME but it can be bound to a variable -->
<!-- FIXME where can it be used? -->
<!-- FIXME examples -->
<!-- FIXME example: ignore function parameter -->
<!-- FIXME example: ignore a field from a tuple -->
<!-- FIXME example: ignore a field from a struct -->
<!-- FIXME example: ignore the field of an enum: use Some(_) -->
<a class="header" href="patterns.html#range-patterns" id="range-patterns"><h2>Range patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>RangePattern</em> :<a name="reference-pattern-syntax"></a><br />
   <em>Expression</em> <code>...</code> <em>Expression</em></p>
</blockquote>
<!-- FIXME: explain range patterns -->
<p>Range patterns match ...</p>
<p>Range patterns only work on scalar types (like integers and characters; not
like arrays and structs, which have sub-components). A range pattern may not be
a sub-range of another range pattern inside the same <code>match</code>.</p>
<!-- FIXME examples -->
<!-- which types can be used here? -->
<!-- FIXME floating point literals use here is being deprecated -->
<a class="header" href="patterns.html#reference-patterns" id="reference-patterns"><h2>Reference patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ReferencePattern</em> :<a name="reference-pattern-syntax"></a><br />
   (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code><sup>?</sup> <em>Pattern</em></p>
</blockquote>
<!-- FIXME: explain reference patterns  -->
<!-- FIXME: explain why the `&&` is part of the grammar -->
<p>Patterns can also dereference pointers by using the <code>&amp;</code>, <code>&amp;mut</code> and <code>box</code>
symbols, as appropriate. For example, these two matches on <code>x: &amp;i32</code> are
equivalent:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# let x = &amp;3;
let y = match *x { 0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };
let z = match x { &amp;0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };

assert_eq!(y, z);

#}</code></pre></pre>
<a class="header" href="patterns.html#identifier-patterns" id="identifier-patterns"><h2>Identifier patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
_IdentifierPattern :<a name="identifier-pattern-syntax"></a><br />
      IDENTIFIER (<code>@</code> <em>Pattern</em> ) <sup>?</sup><br />
   | <code>mut</code> IDENTIFIER (<code>@</code> <em>Pattern</em> ) <sup>?</sup><br />
   | <code>ref</code> <code>mut</code><sup>?</sup> IDENTIFIER (<code>@</code> <em>Pattern</em> ) <sup>?</sup></p>
</blockquote>
<!-- FIXME: explain identifier patterns -->
<!-- FIXME: do not talk about subpatterns initially -->
<!-- FIXME: mention that IDENTIFIER pattern is the commonly used one in let and function parameters -->
<p>Subpatterns can also be bound to variables by the use of the syntax <code>variable @ subpattern</code>. For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}

#}</code></pre></pre>
<p>Patterns that bind variables default to binding to a copy or move of the
matched value (depending on the matched value's type). This can be changed to
bind to a reference by using the <code>ref</code> keyword, or to a mutable reference using
<code>ref mut</code>.</p>
<!-- explain the difference between `& var` and `ref var` in patterns -->
<a class="header" href="patterns.html#box-pattern" id="box-pattern"><h2>Box pattern</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BoxPattern</em> :<a name="box-pattern-syntax"></a><br />
   <code>box</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a></p>
</blockquote>
<!-- FIXME: explain box patterns -->
<!-- FIXME: they're not stable -->
<a class="header" href="patterns.html#struct-patterns" id="struct-patterns"><h2>Struct patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>StructPattern</em> :<a name="struct-pattern-syntax"></a><br />
   <em>Path</em> <code>{</code><br />
      <em>StructPatternElements</em> <sup>?</sup><br />
   <code>}</code></p>
<p><em>StructPatternElements</em> :<br />
      <em>StructPatternFields</em> (<code>,</code> <em>StructPatternEtCetera</em>) ?<br />
   | <em>StructPatternEtCetera</em></p>
<p><em>StructPatternFields</em> :<br />
   <em>StructPatternField</em> (<code>,</code> <em>StructPatternField</em>) <sup>*</sup></p>
<p><em>StructPatternField</em> :<br />
   <em>OuterAttribute</em> <sup>*</sup><br />
   (<br />
         INTEGER_LITERAL <code>:</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a><br />
      | IDENTIFIER <code>:</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a><br />
      | <code>box</code><sup>?</sup> <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup>
IDENTIFIER<br />
   )</p>
<p><em>StructPatternEtCetera</em> :<br />
   <em>OuterAttribute</em> <sup>*</sup><br />
   <code>..</code></p>
</blockquote>
<!-- FIXME: explain struct patterns -->
<!-- FIXME: destructuring patterns -->
<p>Struct patterns match ...</p>
<a class="header" href="patterns.html#tuplestruct-patterns" id="tuplestruct-patterns"><h2>TupleStruct patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleStructPattern</em> :<a name="tuplestruct-pattern-syntax"></a><br />
   <strong>FIXME</strong></p>
</blockquote>
<!-- FIXME: explain tuple struct patterns -->
<!-- FIXME: includes enum variants? Yes! -->
<a class="header" href="patterns.html#tuple-patterns" id="tuple-patterns"><h2>Tuple patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TuplePattern</em> :<a name="tuple-pattern-syntax"></a><br />
   <code>(</code> <em>TupplePatternItems</em><sup>?</sup> <code>)</code></p>
<p><em>TuplePatternItems</em> :<br />
      <a href="patterns.html#pattern-syntax"><em>Pattern</em></a> <code>,</code><br />
   | <a href="patterns.html#pattern-syntax"><em>Pattern</em></a> (<code>,</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup><br />
   | <code>..</code><br />
   | (<a href="patterns.html#pattern-syntax"><em>Pattern</em></a> <code>,</code>)<sup>+</sup> <code>..</code><br />
   | <code>..</code> (<code>,</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup><br />
   | (<a href="patterns.html#pattern-syntax"><em>Pattern</em></a> <code>,</code>)<sup>+</sup> <code>..</code> (<code>,</code> <a href="patterns.html#pattern-syntax"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<!-- FIXME: explain tuple patterns -->
<a class="header" href="patterns.html#slice-patterns" id="slice-patterns"><h2>Slice patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SlicePattern</em> :<a name="slice-pattern-syntax"></a><br />
   <strong>FIXME</strong></p>
</blockquote>
<!-- FIXME: explain slice patterns -->
<!-- FIXME: this is not stable -->
<a class="header" href="patterns.html#path-patterns" id="path-patterns"><h2>Path patterns</h2></a>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PathPattern</em> :<a name="path-pattern-syntax"></a><br />
   <strong>FIXME</strong></p>
</blockquote>
<!-- FIXME: explain paths in patterns -->

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="paths.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="type-system.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="paths.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="type-system.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
