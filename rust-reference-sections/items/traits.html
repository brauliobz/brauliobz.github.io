<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Traits - The Rust Reference</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="notation.html"><strong>1.</strong> Notation</a></li><li><ul class="section"><li><a href="unicode-productions.html"><strong>1.1.</strong> Unicode productions</a></li><li><a href="string-table-productions.html"><strong>1.2.</strong> String table productions</a></li></ul></li><li><a href="lexical-structure.html"><strong>2.</strong> Lexical structure</a></li><li><ul class="section"><li><a href="input-format.html"><strong>2.1.</strong> Input format</a></li><li><a href="keywords.html"><strong>2.2.</strong> Keywords</a></li><li><a href="identifiers.html"><strong>2.3.</strong> Identifiers</a></li><li><a href="comments.html"><strong>2.4.</strong> Comments</a></li><li><a href="whitespace.html"><strong>2.5.</strong> Whitespace</a></li><li><a href="tokens.html"><strong>2.6.</strong> Tokens</a></li><li><a href="paths.html"><strong>2.7.</strong> Paths</a></li></ul></li><li><a href="macros.html"><strong>3.</strong> Macros</a></li><li><ul class="section"><li><a href="macros-by-example.html"><strong>3.1.</strong> Macros By Example</a></li><li><a href="procedural-macros.html"><strong>3.2.</strong> Procedural Macros</a></li></ul></li><li><a href="crates-and-source-files.html"><strong>4.</strong> Crates and source files</a></li><li><a href="items-and-attributes.html"><strong>5.</strong> Items and attributes</a></li><li><ul class="section"><li><a href="items.html"><strong>5.1.</strong> Items</a></li><li><ul class="section"><li><a href="items/extern-crates.html"><strong>5.1.1.</strong> Extern crates</a></li><li><a href="items/use-declarations.html"><strong>5.1.2.</strong> Use declarations</a></li><li><a href="items/modules.html"><strong>5.1.3.</strong> Modules</a></li><li><a href="items/functions.html"><strong>5.1.4.</strong> Functions</a></li><li><a href="items/external-blocks.html"><strong>5.1.5.</strong> External blocks</a></li><li><a href="items/type-aliases.html"><strong>5.1.6.</strong> Type aliases</a></li><li><a href="items/structs.html"><strong>5.1.7.</strong> Structs</a></li><li><a href="items/enumerations.html"><strong>5.1.8.</strong> Enumerations</a></li><li><a href="items/unions.html"><strong>5.1.9.</strong> Unions</a></li><li><a href="items/constant-items.html"><strong>5.1.10.</strong> Constant items</a></li><li><a href="items/static-items.html"><strong>5.1.11.</strong> Static items</a></li><li><a href="items/traits.html" class="active"><strong>5.1.12.</strong> Traits</a></li><li><a href="items/implementations.html"><strong>5.1.13.</strong> Implementations</a></li></ul></li><li><a href="visibility-and-privacy.html"><strong>5.2.</strong> Visibility and Privacy</a></li><li><a href="attributes.html"><strong>5.3.</strong> Attributes</a></li></ul></li><li><a href="statements-and-expressions.html"><strong>6.</strong> Statements and expressions</a></li><li><ul class="section"><li><a href="statements.html"><strong>6.1.</strong> Statements</a></li><li><a href="expressions.html"><strong>6.2.</strong> Expressions</a></li><li><ul class="section"><li><a href="expressions/literal_expr.html"><strong>6.2.1.</strong> Literal expressions</a></li><li><a href="expressions/path_expr.html"><strong>6.2.2.</strong> Path expressions</a></li><li><a href="expressions/block_expr.html"><strong>6.2.3.</strong> Block expressions</a></li><li><a href="expressions/operator_expr.html"><strong>6.2.4.</strong> Operator expressions</a></li><li><a href="expressions/array_expr.html"><strong>6.2.5.</strong> Array and index expressions</a></li><li><a href="expressions/tuple_expr.html"><strong>6.2.6.</strong> Tuple and index expressions</a></li><li><a href="expressions/enum_variant_expr.html"><strong>6.2.7.</strong> Enum variant expressions</a></li><li><a href="expressions/call_expr.html"><strong>6.2.8.</strong> Call expressions</a></li><li><a href="expressions/method_call_expr.html"><strong>6.2.9.</strong> Method call expressions</a></li><li><a href="expressions/field_expr.html"><strong>6.2.10.</strong> Field access expressions</a></li><li><a href="expressions/closure_expr.html"><strong>6.2.11.</strong> Closure expressions</a></li><li><a href="expressions/loop_expr.html"><strong>6.2.12.</strong> Loop expressions</a></li><li><a href="expressions/range_expr.html"><strong>6.2.13.</strong> Range expressions</a></li><li><a href="expressions/if_expr.html"><strong>6.2.14.</strong> If expressions</a></li><li><a href="expressions/match_expr.html"><strong>6.2.15.</strong> Match expressions</a></li><li><a href="expressions/return_expr.html"><strong>6.2.16.</strong> Return expressions</a></li></ul></li></ul></li><li><a href="type-system.html"><strong>7.</strong> Type system</a></li><li><ul class="section"><li><a href="types.html"><strong>7.1.</strong> Types</a></li><li><a href="subtyping.html"><strong>7.2.</strong> Subtyping</a></li><li><a href="type-coercions.html"><strong>7.3.</strong> Type coercions</a></li></ul></li><li><a href="special-traits.html"><strong>8.</strong> Special traits</a></li><li><ul class="section"><li><a href="the-copy-trait.html"><strong>8.1.</strong> The Copy trait</a></li><li><a href="the-sized-trait.html"><strong>8.2.</strong> The Sized trait</a></li><li><a href="the-drop-trait.html"><strong>8.3.</strong> The Drop trait</a></li><li><a href="the-deref-trait.html"><strong>8.4.</strong> The Deref trait</a></li><li><a href="the-send-trait.html"><strong>8.5.</strong> The Send trait</a></li><li><a href="the-sync-trait.html"><strong>8.6.</strong> The Sync trait</a></li></ul></li><li><a href="memory-model.html"><strong>9.</strong> Memory model</a></li><li><ul class="section"><li><a href="memory-allocation-and-lifetime.html"><strong>9.1.</strong> Memory allocation and lifetime</a></li><li><a href="memory-ownership.html"><strong>9.2.</strong> Memory ownership</a></li><li><a href="variables.html"><strong>9.3.</strong> Variables</a></li></ul></li><li><a href="linkage.html"><strong>10.</strong> Linkage</a></li><li><a href="unsafety.html"><strong>11.</strong> Unsafety</a></li><li><ul class="section"><li><a href="unsafe-functions.html"><strong>11.1.</strong> Unsafe functions</a></li><li><a href="unsafe-blocks.html"><strong>11.2.</strong> Unsafe blocks</a></li><li><a href="behavior-considered-undefined.html"><strong>11.3.</strong> Behavior considered undefined</a></li><li><a href="behavior-not-considered-unsafe.html"><strong>11.4.</strong> Behavior not considered unsafe</a></li></ul></li><li><a href="influences.html">Appendix: Influences</a></li><li class="affix"><a href="undocumented.html">Appendix: As-yet-undocumented Features</a></li><li class="affix"><a href="glossory.html">Appendix: Glossory</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="items/traits.html#traits" id="traits"><h1>Traits</h1></a>
<p>A <em>trait</em> describes an abstract interface that types can
implement. This interface consists of associated items, which come in
three varieties:</p>
<ul>
<li>functions</li>
<li><a href="items/traits.html#associated-constants">constants</a></li>
<li>types</li>
</ul>
<p>Associated functions whose first parameter is named <code>self</code> are called
methods and may be invoked using <code>.</code> notation (e.g., <code>x.foo()</code>).</p>
<p>All traits define an implicit type parameter <code>Self</code> that refers to
&quot;the type that is implementing this interface&quot;. Traits may also
contain additional type parameters. These type parameters (including
<code>Self</code>) may be constrained by other traits and so forth as usual.</p>
<p>Trait bounds on <code>Self</code> are considered &quot;supertraits&quot;. These are
required to be acyclic.  Supertraits are somewhat different from other
constraints in that they affect what methods are available in the
vtable when the trait is used as a <a href="types.html#trait-objects">trait object</a>.</p>
<p>Traits are implemented for specific types through separate
<a href="items/traits.html#implementations">implementations</a>.</p>
<p>Consider the following trait:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# type Surface = i32;
# type BoundingBox = i32;
trait Shape {
    fn draw(&amp;self, Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}

#}</code></pre></pre>
<p>This defines a trait with two methods. All values that have
<a href="items/traits.html#implementations">implementations</a> of this trait in scope can have their
<code>draw</code> and <code>bounding_box</code> methods called, using <code>value.bounding_box()</code>
<a href="expressions.html#method-call-expressions">syntax</a>.</p>
<p>Traits can include default implementations of methods, as in:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn bar(&amp;self);
    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }
}

#}</code></pre></pre>
<p>Here the <code>baz</code> method has a default implementation, so types that implement
<code>Foo</code> need only implement <code>bar</code>. It is also possible for implementing types
to override a method that has a default implementation.</p>
<p>Type parameters can be specified for a trait to make it generic. These appear
after the trait name, using the same syntax used in <a href="items/traits.html#generic-functions">generic
functions</a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Seq&lt;T&gt; {
    fn len(&amp;self) -&gt; u32;
    fn elt_at(&amp;self, n: u32) -&gt; T;
    fn iter&lt;F&gt;(&amp;self, F) where F: Fn(T);
}

#}</code></pre></pre>
<p>It is also possible to define associated types for a trait. Consider the
following example of a <code>Container</code> trait. Notice how the type is available
for use in the method signatures:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, Self::E);
}

#}</code></pre></pre>
<p>In order for a type to implement this trait, it must not only provide
implementations for every method, but it must specify the type <code>E</code>. Here's
an implementation of <code>Container</code> for the standard library type <code>Vec</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# trait Container {
#     type E;
#     fn empty() -&gt; Self;
#     fn insert(&amp;mut self, Self::E);
# }
impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}

#}</code></pre></pre>
<p>Generic functions may use traits as <em>bounds</em> on their type parameters. This
will have two effects:</p>
<ul>
<li>Only types that have the trait may instantiate the parameter.</li>
<li>Within the generic function, the methods of the trait can be
called on values that have the parameter's type.</li>
</ul>
<p>For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# type Surface = i32;
# trait Shape { fn draw(&amp;self, Surface); }
fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
    sh.draw(surface);
    sh.draw(surface);
}

#}</code></pre></pre>
<p>Traits also define a <a href="types.html#trait-objects">trait object</a> with the same
name as the trait. Values of this type are created by coercing from a
pointer of some specific type to a pointer of trait type. For example,
<code>&amp;T</code> could be coerced to <code>&amp;Shape</code> if <code>T: Shape</code> holds (and similarly
for <code>Box&lt;T&gt;</code>). This coercion can either be implicit or
<a href="expressions.html#type-cast-expressions">explicit</a>. Here is an example of an explicit
coercion:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Shape { }
impl Shape for i32 { }
let mycircle = 0i32;
let myshape: Box&lt;Shape&gt; = Box::new(mycircle) as Box&lt;Shape&gt;;

#}</code></pre></pre>
<p>The resulting value is a box containing the value that was cast, along with
information that identifies the methods of the implementation that was used.
Values with a trait type can have <a href="expressions.html#method-call-expressions">methods called</a> on
them, for any method in the trait, and can be used to instantiate type
parameters that are bounded by the trait.</p>
<p>Trait methods may be static, which means that they lack a <code>self</code> argument.
This means that they can only be called with function call syntax (<code>f(x)</code>) and
not method call syntax (<code>obj.f()</code>). The way to refer to the name of a static
method is to qualify it with the trait name, treating the trait name like a
module. For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Num {
    fn from_i32(n: i32) -&gt; Self;
}
impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}
let x: f64 = Num::from_i32(42);

#}</code></pre></pre>
<p>Traits may inherit from other traits. Consider the following example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }

#}</code></pre></pre>
<p>The syntax <code>Circle : Shape</code> means that types that implement <code>Circle</code> must also
have an implementation for <code>Shape</code>. Multiple supertraits are separated by <code>+</code>,
<code>trait Circle : Shape + PartialEq { }</code>. In an implementation of <code>Circle</code> for a
given type <code>T</code>, methods can refer to <code>Shape</code> methods, since the typechecker
checks that any type with an implementation of <code>Circle</code> also has an
implementation of <code>Shape</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Foo;

trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
impl Shape for Foo {
    fn area(&amp;self) -&gt; f64 {
        0.0
    }
}
impl Circle for Foo {
    fn radius(&amp;self) -&gt; f64 {
        println!(&quot;calling area: {}&quot;, self.area());

        0.0
    }
}

let c = Foo;
c.radius();

#}</code></pre></pre>
<p>In type-parameterized functions, methods of the supertrait may be called on
values of subtrait-bound type parameters. Referring to the previous example of
<code>trait Circle : Shape</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# trait Shape { fn area(&amp;self) -&gt; f64; }
# trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
fn radius_times_area&lt;T: Circle&gt;(c: T) -&gt; f64 {
    // `c` is both a Circle and a Shape
    c.radius() * c.area()
}

#}</code></pre></pre>
<p>Likewise, supertrait methods may also be called on trait objects.</p>
<pre><code class="language-rust ignore"># trait Shape { fn area(&amp;self) -&gt; f64; }
# trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
# impl Shape for i32 { fn area(&amp;self) -&gt; f64 { 0.0 } }
# impl Circle for i32 { fn radius(&amp;self) -&gt; f64 { 0.0 } }
# let mycircle = 0i32;
let mycircle = Box::new(mycircle) as Box&lt;Circle&gt;;
let nonsense = mycircle.radius() * mycircle.area();
</code></pre>
<a class="header" href="items/traits.html#associated-constants" id="associated-constants"><h2>Associated Constants</h2></a>
<p>A trait can define constants like this:</p>
<pre><pre class="playpen"><code class="language-rust">trait Foo {
    const ID: i32;
}

impl Foo for i32 {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, i32::ID);
}
</code></pre></pre>
<p>Any implementor of <code>Foo</code> will have to define <code>ID</code>. Without the definition:</p>
<pre><code class="language-rust ignore">trait Foo {
    const ID: i32;
}

impl Foo for i32 {
}
</code></pre>
<p>gives</p>
<pre><code class="language-text">error: not all trait items implemented, missing: `ID` [E0046]
     impl Foo for i32 {
     }
</code></pre>
<p>A default value can be implemented as well:</p>
<pre><pre class="playpen"><code class="language-rust">trait Foo {
    const ID: i32 = 1;
}

impl Foo for i32 {
}

impl Foo for i64 {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, i32::ID);
    assert_eq!(5, i64::ID);
}
</code></pre></pre>
<p>As you can see, when implementing <code>Foo</code>, you can leave it unimplemented, as
with <code>i32</code>. It will then use the default value. But, as in <code>i64</code>, we can also
add our own definition.</p>
<p>Associated constants don’t have to be associated with a trait. An <code>impl</code> block
for a <code>struct</code> or an <code>enum</code> works fine too:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Foo;

impl Foo {
    const FOO: u32 = 3;
}

#}</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="items/static-items.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="items/implementations.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="items/static-items.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="items/implementations.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
