<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Expressions - The Rust Reference</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="notation.html"><strong>1.</strong> Notation</a></li><li><ul class="section"><li><a href="unicode-productions.html"><strong>1.1.</strong> Unicode productions</a></li><li><a href="string-table-productions.html"><strong>1.2.</strong> String table productions</a></li></ul></li><li><a href="lexical-structure.html"><strong>2.</strong> Lexical structure</a></li><li><ul class="section"><li><a href="input-format.html"><strong>2.1.</strong> Input format</a></li><li><a href="keywords.html"><strong>2.2.</strong> Keywords</a></li><li><a href="identifiers.html"><strong>2.3.</strong> Identifiers</a></li><li><a href="comments.html"><strong>2.4.</strong> Comments</a></li><li><a href="whitespace.html"><strong>2.5.</strong> Whitespace</a></li><li><a href="tokens.html"><strong>2.6.</strong> Tokens</a></li><li><a href="paths.html"><strong>2.7.</strong> Paths</a></li></ul></li><li><a href="macros.html"><strong>3.</strong> Macros</a></li><li><ul class="section"><li><a href="macros-by-example.html"><strong>3.1.</strong> Macros By Example</a></li><li><a href="procedural-macros.html"><strong>3.2.</strong> Procedural Macros</a></li></ul></li><li><a href="crates-and-source-files.html"><strong>4.</strong> Crates and source files</a></li><li><a href="items-and-attributes.html"><strong>5.</strong> Items and attributes</a></li><li><ul class="section"><li><a href="items.html"><strong>5.1.</strong> Items</a></li><li><ul class="section"><li><a href="items/extern-crates.html"><strong>5.1.1.</strong> Extern crates</a></li><li><a href="items/use-declarations.html"><strong>5.1.2.</strong> Use declarations</a></li><li><a href="items/modules.html"><strong>5.1.3.</strong> Modules</a></li><li><a href="items/functions.html"><strong>5.1.4.</strong> Functions</a></li><li><a href="items/external-blocks.html"><strong>5.1.5.</strong> External blocks</a></li><li><a href="items/type-aliases.html"><strong>5.1.6.</strong> Type aliases</a></li><li><a href="items/structs.html"><strong>5.1.7.</strong> Structs</a></li><li><a href="items/enumerations.html"><strong>5.1.8.</strong> Enumerations</a></li><li><a href="items/unions.html"><strong>5.1.9.</strong> Unions</a></li><li><a href="items/constant-items.html"><strong>5.1.10.</strong> Constant items</a></li><li><a href="items/static-items.html"><strong>5.1.11.</strong> Static items</a></li><li><a href="items/traits.html"><strong>5.1.12.</strong> Traits</a></li><li><a href="items/implementations.html"><strong>5.1.13.</strong> Implementations</a></li></ul></li><li><a href="visibility-and-privacy.html"><strong>5.2.</strong> Visibility and Privacy</a></li><li><a href="attributes.html"><strong>5.3.</strong> Attributes</a></li></ul></li><li><a href="statements-and-expressions.html"><strong>6.</strong> Statements and expressions</a></li><li><ul class="section"><li><a href="statements.html"><strong>6.1.</strong> Statements</a></li><li><a href="expressions.html" class="active"><strong>6.2.</strong> Expressions</a></li><li><ul class="section"><li><a href="expressions/literal_expr.html"><strong>6.2.1.</strong> Literal expressions</a></li><li><a href="expressions/path_expr.html"><strong>6.2.2.</strong> Path expressions</a></li><li><a href="expressions/block_expr.html"><strong>6.2.3.</strong> Block expressions</a></li><li><a href="expressions/operator_expr.html"><strong>6.2.4.</strong> Operator expressions</a></li><li><a href="expressions/array_expr.html"><strong>6.2.5.</strong> Array and index expressions</a></li><li><a href="expressions/tuple_expr.html"><strong>6.2.6.</strong> Tuple and index expressions</a></li><li><a href="expressions/enum_variant_expr.html"><strong>6.2.7.</strong> Enum variant expressions</a></li><li><a href="expressions/call_expr.html"><strong>6.2.8.</strong> Call expressions</a></li><li><a href="expressions/method_call_expr.html"><strong>6.2.9.</strong> Method call expressions</a></li><li><a href="expressions/field_expr.html"><strong>6.2.10.</strong> Field access expressions</a></li><li><a href="expressions/closure_expr.html"><strong>6.2.11.</strong> Closure expressions</a></li><li><a href="expressions/loop_expr.html"><strong>6.2.12.</strong> Loop expressions</a></li><li><a href="expressions/range_expr.html"><strong>6.2.13.</strong> Range expressions</a></li><li><a href="expressions/if_expr.html"><strong>6.2.14.</strong> If expressions</a></li><li><a href="expressions/match_expr.html"><strong>6.2.15.</strong> Match expressions</a></li><li><a href="expressions/return_expr.html"><strong>6.2.16.</strong> Return expressions</a></li></ul></li></ul></li><li><a href="type-system.html"><strong>7.</strong> Type system</a></li><li><ul class="section"><li><a href="types.html"><strong>7.1.</strong> Types</a></li><li><a href="subtyping.html"><strong>7.2.</strong> Subtyping</a></li><li><a href="type-coercions.html"><strong>7.3.</strong> Type coercions</a></li></ul></li><li><a href="special-traits.html"><strong>8.</strong> Special traits</a></li><li><ul class="section"><li><a href="the-copy-trait.html"><strong>8.1.</strong> The Copy trait</a></li><li><a href="the-sized-trait.html"><strong>8.2.</strong> The Sized trait</a></li><li><a href="the-drop-trait.html"><strong>8.3.</strong> The Drop trait</a></li><li><a href="the-deref-trait.html"><strong>8.4.</strong> The Deref trait</a></li><li><a href="the-send-trait.html"><strong>8.5.</strong> The Send trait</a></li><li><a href="the-sync-trait.html"><strong>8.6.</strong> The Sync trait</a></li></ul></li><li><a href="memory-model.html"><strong>9.</strong> Memory model</a></li><li><ul class="section"><li><a href="memory-allocation-and-lifetime.html"><strong>9.1.</strong> Memory allocation and lifetime</a></li><li><a href="memory-ownership.html"><strong>9.2.</strong> Memory ownership</a></li><li><a href="variables.html"><strong>9.3.</strong> Variables</a></li></ul></li><li><a href="linkage.html"><strong>10.</strong> Linkage</a></li><li><a href="unsafety.html"><strong>11.</strong> Unsafety</a></li><li><ul class="section"><li><a href="unsafe-functions.html"><strong>11.1.</strong> Unsafe functions</a></li><li><a href="unsafe-blocks.html"><strong>11.2.</strong> Unsafe blocks</a></li><li><a href="behavior-considered-undefined.html"><strong>11.3.</strong> Behavior considered undefined</a></li><li><a href="behavior-not-considered-unsafe.html"><strong>11.4.</strong> Behavior not considered unsafe</a></li></ul></li><li><a href="influences.html">Appendix: Influences</a></li><li class="affix"><a href="undocumented.html">Appendix: As-yet-undocumented Features</a></li><li class="affix"><a href="glossory.html">Appendix: Glossory</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="expressions.html#expressions" id="expressions"><h1>Expressions</h1></a>
<p>An expression may have two roles: it always produces a <em>value</em>, and it may have
<em>effects</em> (otherwise known as &quot;side effects&quot;). An expression <em>evaluates to</em> a
value, and has effects during <em>evaluation</em>. Many expressions contain
sub-expressions (operands). The meaning of each kind of expression dictates
several things:</p>
<ul>
<li>Whether or not to evaluate the sub-expressions when evaluating the expression</li>
<li>The order in which to evaluate the sub-expressions</li>
<li>How to combine the sub-expressions' values to obtain the value of the
expression</li>
</ul>
<p>In this way, the structure of expressions dictates the structure of execution.
Blocks are just another kind of expression, so blocks, statements, expressions,
and blocks again can recursively nest inside each other to an arbitrary depth.</p>
<a class="header" href="expressions.html#lvalues-and-rvalues" id="lvalues-and-rvalues"><h2>Lvalues and rvalues</h2></a>
<p>Expressions are divided into two main categories: <em>lvalues</em> and <em>rvalues</em>.
Likewise within each expression, sub-expressions may occur in <em>lvalue context</em>
or <em>rvalue context</em>. The evaluation of an expression depends both on its own
category and the context it occurs within.</p>
<p>An lvalue is an expression that represents a memory location. These expressions
are <a href="expressions.html#path-expressions">paths</a> which refer to local variables, function and
method arguments, or static variables,
<a href="expressions.html#the-dereference-operator">dereferences</a> (<code>*expr</code>), <a href="expressions.html#index-expressions">indexing
expressions</a> (<code>expr[expr]</code>), <a href="expressions.html#field-expressions">field
references</a> (<code>expr.f</code>) and parenthesized lvalue
expressions. All other expressions are rvalues.</p>
<p>The left operand of an <a href="expressions.html#assignment-expressions">assignment</a> or
<a href="expressions.html#compound-assignment-expressions">compound-assignment</a> expression is an lvalue
context, as is the single operand of a unary <a href="expressions.html#borrow-operators">borrow</a>, and
the operand of any <a href="expressions.html#implicit-borrows">implicit borrow</a>. The discriminant or
subject of a <a href="expressions.html#match-expressions">match expression</a> and right side of a <code>let</code>
binding may be an lvalue context, if ref bindings are made, but is otherwise an
rvalue context. All other expression contexts are rvalue contexts.</p>
<a class="header" href="expressions.html#moved-and-copied-types" id="moved-and-copied-types"><h3>Moved and copied types</h3></a>
<p>When an lvalue is evaluated in an <em>rvalue context</em>, it denotes the value held
<em>in</em> that memory location. If value is of a type that implements <code>Copy</code>, then
the value will be copied. In the remaining situations if the type of the value
is <a href="the-sized-trait.html"><code>Sized</code></a> it may be possible to move the value. Only
the following lvalues may be moved out of:</p>
<ul>
<li><a href="variables.html">Variables</a> which are not currently borrowed.</li>
<li><a href="expressions.html#temporary-lifetimes">Temporary values</a>.</li>
<li><a href="expressions.html#field-expressions">Fields</a> of an lvalue which can be moved out of and
doesn't implement <a href="the-drop-trait.html"><code>Drop</code></a>.</li>
<li>The result of <a href="expressions.html#the-dereference-operator">dereferencing</a> an expression with
type <code>Box&lt;T&gt;</code> and that can also be moved out of.</li>
</ul>
<p>Moving out of an lvalue deinitializes that location (if it comes from a local
variable), so that it can't be read from again. In all other cases, trying to
use an lvalue in an rvalue context is an error.</p>
<a class="header" href="expressions.html#mutability" id="mutability"><h3>Mutability</h3></a>
<p>For an lvalue to be <a href="expressions.html#assignment-expressions">assigned</a> to, <a href="expressions.html#borrow-operators">mutably
borrowed</a>, <a href="expressions.html#implicit-borrows">implicitly mutably borrowed</a>
or bound to a pattern containing <code>ref mut</code> it must be <em>mutable</em>, we call these
contexts <em>mutable</em> lvalue contexts, other lvalue contexts are called
<em>immutable</em>.</p>
<p>The following expressions can create mutable lvalues:</p>
<ul>
<li>Mutable <a href="variables.html">variables</a>, which are not currently borrowed.</li>
<li><a href="items.html#mutable-statics">Mutable <code>static</code> items</a>.</li>
<li><a href="expressions.html#temporary-lifetimes">Temporary values</a>.</li>
<li><a href="expressions.html#field-expressions">Fields</a>, this evaluates the subexpression in a mutable
lvalue context.</li>
<li><a href="expressions.html#the-dereference-operator">Dereferences</a> of a <code>*mut T</code> pointer.</li>
<li>Dereference of a variable, or field of a variable, with type <code>&amp;mut T</code>. Note:
this is an exception to the requirement for the next rule.</li>
<li>Dereferences of a type that implements <code>DerefMut</code>, this then requires that
the value being dereferenced is evaluated is a mutable lvalue context.</li>
<li><a href="expressions.html#index-expressions">Indexing</a> of a type that implements <code>DerefMut</code>, this
then evaluates the value being indexed (but not the index) in mutable lvalue
context.</li>
</ul>
<a class="header" href="expressions.html#temporary-lifetimes" id="temporary-lifetimes"><h3>Temporary lifetimes</h3></a>
<p>When using an rvalue in most lvalue contexts, a temporary unnamed lvalue is
created and used instead. The lifetime of temporary values is typically</p>
<ul>
<li>the innermost enclosing statement; the tail expression of a block is
considered part of the statement that encloses the block, or</li>
<li>the condition expression or the loop conditional expression if the
temporary is created in the condition expression of an <code>if</code> or an <code>if</code>/<code>else</code>
or in the loop conditional expression of a <code>while</code> expression.</li>
</ul>
<p>When a temporary rvalue is being created that is assigned into a <code>let</code>
declaration, however, the temporary is created with the lifetime of the
enclosing block instead, as using the enclosing statement (the <code>let</code>
declaration) would be a guaranteed error (since a pointer to the temporary
would be stored into a variable, but the temporary would be freed before the
variable could be used). The compiler uses simple syntactic rules to decide
which values are being assigned into a <code>let</code> binding, and therefore deserve a
longer temporary lifetime.</p>
<p>Here are some examples:</p>
<ul>
<li><code>let x = foo(&amp;temp())</code>. The expression <code>temp()</code> is an rvalue. As it
is being borrowed, a temporary is created which will be freed after
the innermost enclosing statement (the <code>let</code> declaration, in this case).</li>
<li><code>let x = temp().foo()</code>. This is the same as the previous example,
except that the value of <code>temp()</code> is being borrowed via autoref on a
method-call. Here we are assuming that <code>foo()</code> is an <code>&amp;self</code> method
defined in some trait, say <code>Foo</code>. In other words, the expression
<code>temp().foo()</code> is equivalent to <code>Foo::foo(&amp;temp())</code>.</li>
<li><code>let x = if foo(&amp;temp()) {bar()} else {baz()};</code>. The expression <code>temp()</code> is
an rvalue. As the temporary is created in the condition expression
of an <code>if</code>/<code>else</code>, it will be freed at the end of the condition expression
(in this example before the call to <code>bar</code> or <code>baz</code> is made).</li>
<li><code>let x = if temp().must_run_bar {bar()} else {baz()};</code>.
Here we assume the type of <code>temp()</code> is a struct with a boolean field
<code>must_run_bar</code>. As the previous example, the temporary corresponding to
<code>temp()</code> will be freed at the end of the condition expression.</li>
<li><code>while foo(&amp;temp()) {bar();}</code>. The temporary containing the return value from
the call to <code>temp()</code> is created in the loop conditional expression. Hence it
will be freed at the end of the loop conditional expression (in this example
before the call to <code>bar</code> if the loop body is executed).</li>
<li><code>let x = &amp;temp()</code>. Here, the same temporary is being assigned into
<code>x</code>, rather than being passed as a parameter, and hence the
temporary's lifetime is considered to be the enclosing block.</li>
<li><code>let x = SomeStruct { foo: &amp;temp() }</code>. As in the previous case, the
temporary is assigned into a struct which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let x = [ &amp;temp() ]</code>. As in the previous case, the
temporary is assigned into an array which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let ref x = temp()</code>. In this case, the temporary is created using a ref binding,
but the result is the same: the lifetime is extended to the enclosing block.</li>
</ul>
<a class="header" href="expressions.html#implicit-borrows" id="implicit-borrows"><h3>Implicit Borrows</h3></a>
<p>Certain expressions will treat an expression as an lvalue by implicitly
borrowing it. For example, it is possible to compare two unsized
<a href="types.html#array-and-slice-types">slices</a> for equality directly, because the
<code>==</code> operator implicitly borrows it's operands:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# let c = [1, 2, 3];
# let d = vec![1, 2, 3];
let a: &amp;[i32];
let b: &amp;[i32];
# a = &amp;c;
# b = &amp;d;
// ...
*a == *b;
// Equivalent form:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);

#}</code></pre></pre>
<p>Implicit borrows may be taken in the following expressions:</p>
<ul>
<li>Left operand in <a href="expressions.html#method-call-expressions">method-call expressions</a>.</li>
<li>Left operand in <a href="expressions.html#field-expressions">field expressions</a>.</li>
<li>Left operand in <a href="expressions.html#call-expressions">call expressions</a>.</li>
<li>Left operand in <a href="expressions.html#index-expressions">index expressions</a>.</li>
<li>Operand of the <a href="expressions.html#the-dereference-operator">dereference</a> (<code>*</code>) operator.</li>
<li>Operands of <a href="expressions.html#comparison-operators">comparison operators</a>.</li>
<li>Left operands of the <a href="expressions.html#compound-assignment-expressions">compound assignment</a>.</li>
</ul>
<a class="header" href="expressions.html#constant-expressions" id="constant-expressions"><h2>Constant expressions</h2></a>
<p>Certain types of expressions can be evaluated at compile time. These are called
<em>constant expressions</em>. Certain places, such as in
<a href="items.html#constant-items">constants</a> and <a href="items.html#static-items">statics</a>,
require a constant expression, and are always evaluated at compile time. In
other places, such as in <a href="statements.html#let-statements"><code>let</code> statements</a>,
constant expressions may be evaluated at compile time. If errors, such as out
of bounds <a href="expressions.html#index-expressions">array access</a> or <a href="expressions.html#overflow">overflow</a> occurs,
then it is a compiler error if the value must be evaluated at compile time,
otherwise it is just a warning, but the code will most likely panic when run.</p>
<p>The following expressions are constant expressions, so long as any operands are
also constant expressions:</p>
<ul>
<li><a href="expressions.html#literal-expressions">Literals</a>.</li>
<li><a href="expressions.html#path-expressions">Paths</a> to <a href="items.html#functions">functions</a> and constants.
Recursively defining constants is not allowed.</li>
<li>Paths to statics, so long as only their address, not their value, is used.
This includes using their value indirectly through a complicated expression.
*</li>
<li><a href="expressions.html#tuple-expressions">Tuple expressions</a>.</li>
<li><a href="expressions.html#array-expressions">Array expressions</a>.</li>
<li><a href="expressions.html#struct-expressions">Struct expressions</a>, where the type does not implement
<a href="the-drop-trait.html"><code>Drop</code></a>.</li>
<li><a href="expressions.html#enumeration-variant-expressions">Variant expressions</a>, where the
enumeration type does not implement <code>Drop</code>.</li>
<li><a href="expressions.html#block-expressions">Block expressions</a> (and <code>unsafe</code> blocks) which contain
only items and possibly a (constant) tail expression.</li>
<li><a href="expressions.html#field-expressions">Field expressions</a>.</li>
<li><a href="expressions.html#index-expressions">Index expressions</a>, indexing a <a href="types.html#array-and-slice-types">array or
slice</a> with a <code>usize</code>.</li>
<li><a href="expressions.html#range-expressions">Range expressions</a>.</li>
<li><a href="expressions.html#closure-expressions">Closure expressions</a> which don't capture variables
from the environment.</li>
<li>Built in <a href="expressions.html#negation-operators">negation</a>, <a href="expressions.html#arithmetic-and-logical-binary-operators">arithmetic,
logical</a>,
<a href="expressions.html#comparison-operators">comparison</a> or <a href="expressions.html#lazy-boolean-operators">lazy
boolean</a> operators used on integer and floating
point types, <code>bool</code> and <code>char</code>.</li>
<li>Shared <a href="expressions.html#borrow-operators">borrow expressions</a>.</li>
<li>The <a href="expressions.html#the-dereference-operator">dereference operator</a>, but not to circumvent the
rule on statics.</li>
<li><a href="expressions.html#grouped-expressions">Grouped expressions</a>.</li>
<li><a href="expressions.html#type-cast-expressions">Cast expressions</a>, except pointer to address and
function pointer to address casts.</li>
</ul>
<p>* Only in static items.</p>
<a class="header" href="expressions.html#overloading-traits" id="overloading-traits"><h2>Overloading Traits</h2></a>
<p>Many of the following operators and expressions can also be overloaded for
other types using traits in <code>std::ops</code> or <code>std::cmp</code>, these traits here also
exist in <code>core::ops</code> and <code>core::cmp</code> with the same names.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="statements.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="expressions/literal_expr.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="statements.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="expressions/literal_expr.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
